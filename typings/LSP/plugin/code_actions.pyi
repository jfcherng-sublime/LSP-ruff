import sublime
from .core.promise import Promise as Promise
from .core.protocol import CodeAction as CodeAction, CodeActionKind as CodeActionKind, Command as Command, Diagnostic as Diagnostic, Error as Error, Request as Request
from .core.registry import LspTextCommand as LspTextCommand, LspWindowCommand as LspWindowCommand, windows as windows
from .core.sessions import AbstractViewListener as AbstractViewListener, SessionBufferProtocol as SessionBufferProtocol
from .core.settings import userprefs as userprefs
from .core.views import entire_content_region as entire_content_region, first_selection_region as first_selection_region, format_code_actions_for_quick_panel as format_code_actions_for_quick_panel, kind_contains_other_kind as kind_contains_other_kind, text_document_code_action_params as text_document_code_action_params
from .save_command import LspSaveCommand as LspSaveCommand, SaveTask as SaveTask
from _typeshed import Incomplete
from abc import ABCMeta, abstractmethod
from typing_extensions import TypeGuard

ConfigName = str
CodeActionOrCommand = CodeAction | Command
CodeActionsByConfigName = tuple[ConfigName, list[CodeActionOrCommand]]
MENU_ACTIONS_KINDS: Incomplete

def is_command(action: CodeActionOrCommand) -> TypeGuard[Command]: ...

class CodeActionsManager:
    menu_actions_cache_key: Incomplete
    refactor_actions_cache: Incomplete
    source_actions_cache: Incomplete
    def __init__(self) -> None: ...
    def request_for_region_async(self, view: sublime.View, region: sublime.Region, session_buffer_diagnostics: list[tuple[SessionBufferProtocol, list[Diagnostic]]], only_kinds: list[CodeActionKind] | None = None, manual: bool = False) -> Promise[list[CodeActionsByConfigName]]: ...
    def request_on_save_async(self, view: sublime.View, on_save_actions: dict[str, bool]) -> Promise[list[CodeActionsByConfigName]]: ...

actions_manager: Incomplete

def get_session_kinds(sb: SessionBufferProtocol) -> list[CodeActionKind]: ...
def get_matching_on_save_kinds(user_actions: dict[str, bool], session_kinds: list[CodeActionKind]) -> list[CodeActionKind]: ...

class CodeActionOnSaveTask(SaveTask):
    @classmethod
    def is_applicable(cls, view: sublime.View) -> bool: ...
    def run_async(self) -> None: ...

class LspCodeActionsCommand(LspTextCommand):
    capability: str
    def is_visible(self, event: dict | None = None, point: int | None = None, only_kinds: list[CodeActionKind] | None = None) -> bool: ...
    def run(self, edit: sublime.Edit, event: dict | None = None, only_kinds: list[CodeActionKind] | None = None, code_actions_by_config: list[CodeActionsByConfigName] | None = None) -> None: ...

class LspMenuActionCommand(LspWindowCommand, metaclass=ABCMeta):
    capability: str
    @property
    @abstractmethod
    def actions_cache(self) -> list[tuple[str, CodeAction]]: ...
    @property
    def view(self) -> sublime.View | None: ...
    def is_enabled(self, index: int, event: dict | None = None) -> bool: ...
    def is_visible(self, index: int, event: dict | None = None) -> bool: ...
    def description(self, index: int, event: dict | None = None) -> str | None: ...
    def want_event(self) -> bool: ...
    def run(self, index: int, event: dict | None = None) -> None: ...
    def run_async(self, index: int, event: dict | None) -> None: ...
    @staticmethod
    def applies_to_context_menu(event: dict | None) -> bool: ...

class LspRefactorCommand(LspMenuActionCommand):
    @property
    def actions_cache(self) -> list[tuple[str, CodeAction]]: ...

class LspSourceActionCommand(LspMenuActionCommand):
    @property
    def actions_cache(self) -> list[tuple[str, CodeAction]]: ...
